<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js vr - panorama with depth</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>
  <body>
    <div id="container"></div>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three/build/three.module.js",
          "three/addons/": "https://unpkg.com/three/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";

      import { VRButton } from "three/addons/webxr/VRButton.js";

      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
      import { PMREMGenerator } from "/node_modules/three/src/extras/PMREMGenerator.js";
      let currentTextureIndex = 0; // keeps track of the current texture index

      // set up click event handlers for the buttons
      document.getElementById("prevButton");
      co.addEventListener("click", prevTexture);
      document
        .getElementById("nextButton")
        .addEventListener("click", nextTexture);

      function prevTexture() {
        // decrement the texture index and loop back to the end if necessary
        currentTextureIndex--;
        if (currentTextureIndex < 0) {
          currentTextureIndex = 1;
        }

        // get the current sphere mesh and replace its texture with the previous one
        const currentSphere = scene.children.find(
          (child) => child.type === "Mesh"
        );
        const currentMaterial = currentSphere.material;
        const currentTexture = currentMaterial.map;
        const previousTextureIndex =
          currentTextureIndex - 1 < 0 ? 1 : currentTextureIndex - 1;
        const previousTexture = textures[previousTextureIndex];
        currentTexture.dispose();
        currentMaterial.map = previousTexture;
        currentTextureIndex = previousTextureIndex;
      }

      function nextTexture() {
        // increment the texture index and loop back to the start if necessary
        currentTextureIndex++;
        if (currentTextureIndex > 1) {
          currentTextureIndex = 0;
        }

        // get the current sphere mesh and replace its texture with the next one
        const currentSphere = scene.children.find(
          (child) => child.type === "Mesh"
        );
        const currentMaterial = currentSphere.material;
        const currentTexture = currentMaterial.map;
        const nextTextureIndex =
          currentTextureIndex + 1 > 1 ? 0 : currentTextureIndex + 1;
        const nextTexture = textures[nextTextureIndex];
        currentTexture.dispose();
        currentMaterial.map = nextTexture;
        currentTextureIndex = nextTextureIndex;
      }

      // load the textures and create the meshes
      const textures = [];
      const loader = new THREE.TextureLoader();
      loader.load("models/kirjasto(1).jpg", (texture) => {
        texture.generateMipmaps = false;
        textures.push(texture);

        if (textures.length === 2) {
          // both textures have loaded, create the meshes
          const panoSphereGeo = new THREE.SphereGeometry(6, 256, 256);

          for (let i = 0; i < textures.length; i++) {
            const texture = textures[i];
            const material = new THREE.MeshStandardMaterial({
              map: texture,
              side: THREE.BackSide,
              displacementScale: -4.0,
            });
            const mesh = new THREE.Mesh(panoSphereGeo, material);
            mesh.position.set(0, 0, -20 * i);
            group.add(mesh);
          }

          // add the meshes to the scene and render
          scene.add(group);
          render();
        }
      });

      function render() {
        renderer.setAnimationLoop(() => {
          update();
          renderer.render(scene, camera);
        });
      }

      function update() {
        // update any relevant scene objects
      }
    </script>
  </body>
</html>
